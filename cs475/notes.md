CS 475 - Programming Languages
==============================

## Regular Expressions - 28 August 2013

- TERM: Regular Expression = 
- TERM: Operators (in order of increasing precedence)
	- Union = or
	- Concatenation = (normal def.)
	- Asterisk (*) = repeat zero or more times

- EXAMPLE
	- strings over {a, b} with the 4rd rightmost symbol being "b"
	- (a UNION b)* b (a UNION b) (a UNION b)

##### Convert regex to NFSM

- notebook-7

- The NFSMs we construct will have one final state, and that state will be distinct from the start state.

- notebook-8

- notebook-9

- notebook-10

- IMAGE @ 1:45

- IMAGE @ 1:50

## Regular Expressions (cont.) - 4 September 2013

- Example:
	- Identifiers (start with a letter, and the rest of the characters are either letters, digits, or underscores)
	- letter(letter|digit|"_")*
	- the first instance of letter above is same as [a-z]|[A-Z] or [a-zA-Z]
	- same goes for digit: [0-9]
	- full regex: \[a-zA-Z]([a-zA-Z]|[0-9]|"_")*

- Example:
	- write an expression that captures any string over {a, b} where the # of a's is odd (inclusive) or the # of b's is odd.
	- jsut the a part: a(aa)\*
	- both: b*ab*(\*ab\*)\*|a\*ba\*(ba\*ba\*)\*

- Example:
	- converting from regex to non-deterministic finite state machine
	- notebook-17

##### more regex shorthands

- ? means optional. Ex: [0-9]? means a digit is optional
- Epsilon represents the empty string

##### Regex Properties

- Associative:
	- (RS)T = R(ST) = RST
	- (R|S)|T = R|(S|T) = R|S|T

- Commutative:
	- R|S = S|R
	- RS != SR

- Distributive:
	- R(S|T) = RS|RT
		- Remember, concatenation has higher precedence than union.
	- (R|S)T = RT|ST

## Regular Expressions (cont.) - 6 September 2013

- notebook-22

##### Converting FSM to RegExpr

- notebook-23
- Algorithm:
	- If either we have 2 or more final states OR the start state is a final state, create a new version of the FSM with the final states removed, then add an additional state that is final, along with epsilon edges/transitions leading to it from all of the original final states.
- general example: notebook-24
	- Once you're down to 2 states you can easily create regex.

- pseudocode for elimination process: notebook-25

- TERM: "Regular Language" = A language that is accepted by an FSM or generated by regex.

- example of a non-regular language
	- L = {AnBn}   (where n is an exponent in place of the *).
	- machine for above, notebook-26
	- How can we actually show/prove that L is not regular? 
		- There is a property that all regular languages have. Here are some properties of Regular Languages:
			- Suppose R is a RegLang.
			- Let M be a DFSM that accepts R.
			- Let P equal the number of states in M.
			- Suppose R contains a string S with length >= P.
			- notebook-27 for picture.
			- Accepting string S yields a path in machine M that includes >= P+1 states, and thus repeats at least one state.
			- Call the sequence of characters along the path from the start state until the first state that gets repeated "path U".
			- Call the set of nodes between visits to the repeated state path V.
			- Finally, call the path between the repeated state and the final state path W.
			- This leads to a theorem:
				- ##### Pumping Theorem for Regular Languages
					- Let L be any regular language.
					- There exists a constant P such that:
						- for every string s element L with len(s) >= p we can write s = uvw such that |uv| <= p and |v| >= 1 and every string u(v^k)w (u concatenated with k repeats of v concatenated to w) is in L for all k >= 0.
		- SO, back to the question (show that L is not regular). We'll use proof by contradiction.
			- Assume L is regular.
			- Choose a constant P.
			- let s = (a^p)(b^p). That is, p a's concatenated with p b's.
			- So, s = uvw where u = a^i (that is, some number of a's) and v = a^j (again, some number of a's). These must be true by the property of the pumping theorem.
			- Thus, w must = (a^(p-i-j))(b^p) (that is, the rest of the a's, then all of the b's).
			- By the second condition of the theorem, j >= 1.
			- Now, the contradiction. Choose any k to use in the third condition.
				- notebook-28

- Another example like above: notebook-32, notebook-33, notebook-34