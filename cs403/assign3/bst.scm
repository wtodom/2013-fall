(define debug #f)
(define (bst)
	(define count 0)
	(define base (cons nil (list nil nil)))
	(define (size+) (set! count (+ count 1)))
	(define (size-) (set! count (- count 1)))
	(define (leftChild node)
		(cadr node)
		)
	(define (rightChild node)
		(cadr (cdr node))
		)
	(define (size)
		count
		)
	(define (root)
		(car base)
		)
	(define (find val)
		(define (find-helper node)
			(cond
				((null? node) #f)
				((= val (car node))
					#t
					)
				((< val (car node))
					(find-helper (leftChild node))
					)
				((> val (car node))
					(find-helper (rightChild node))
					)
				)
			)
		(find-helper base)
		)
	(define (insert @)
		(for-each insert-helper @)
		)
	(define (insert-helper x)
		(if debug (newline))
		(if debug (println "Current tree: " base))
		(if debug (println "Attempting to insert " x "..."))
		(define (insertWalker node)
			(if debug (println "Node: " node))
			(cond
				((< x (car node))
					(if debug (println x " was smaller than " (car node) ". Checking left child..."))
					(cond
						((null? (leftChild node))
							(if debug (println "left child was null. inserting."))
							(set-car! (cdr node) (cons x (list nil nil)))
							(size+)
							)
						(else
							(if debug (println "left child was not null. recurring..."))
							(insertWalker (leftChild node))
							)
						)
					)
				(else ; (> x (car node))
					(if debug (println x " was bigger than " (car node) ". Checking right child..."))
					(cond
						((null? (rightChild node))
							(if debug (println "right child was null. inserting."))
							(set-car! (cddr node) (cons x (list nil nil)))
							(size+)
							)
						(else
							(if debug (println "right child was not null. recurring..."))
							(insertWalker (rightChild node))
							)
						)
					)
				)
			)
		(cond
			((null? (root))
				(if debug (println "root was null. inserting."))
				(set-car! base x)
				(size+)
				)
			(else
				(insertWalker base)
				)
			)
		)
	(define (predecessor node)
		(define (p-helper node)
			(cond
				((null? (rightChild node))
					node
					)
				(else
					(p-helper (rightChild node))
					)
				)
			)
		(p-helper (leftChild node))
		)
	(define (successor node)
		(define (p-helper node)
			(cond
				((null? (leftChild node))
					node
					)
				(else
					(p-helper (leftChild node))
					)
				)
			)
		(p-helper (rightChild node))
		)
	(define (delete val)
		(define (parent node)
			(define (tracer curr)
				(cond
					((or (eq? (leftChild curr) node) (eq? (rightChild curr) node))
						curr
						)
					(else
						(if (> (car curr) (car node))
							(tracer (leftChild curr))
						; else
							(tracer (rightChild curr))
							)
						)
					)
				)
			(tracer base)
			)
		(define (delete-helper node)
			(if debug (inspect (car node)))
			(if debug (inspect val))
			; (if (pair? val) (set! val (car val)))
			(cond
				((null? node) nil)
				((< val (car node))
					(if debug (println val " is less than " (car node) ". recurring left."))
					(delete-helper (leftChild node))
					)
				((> val (car node))
					(if debug (println val " is more than " (car node) ". recurring right."))
					(delete-helper (rightChild node))
					)
				(else
					(if debug (println val " is " (car node) ". beginning delete."))
					(cond
						((and (null? (rightChild node)) (null? (leftChild node)))
						(if debug (println "Both children are null. Deleting..."))
							; (inspect node))
							; (inspect (parent node)))
							; (inspect (eq? (rightChild (parent node)) node)))
							(if (eq? (rightChild (parent node)) node)
								(set-car! (cddr (parent node)) nil)
								(set-car! (cdr (parent node)) nil)
								)
							(size-)
							; (set-cdr! (parent node) (list nil nil))
							)
						((null? (rightChild node))
							(if debug (println "Right child is null.  Replacing node with " (leftChild node)))
							; (set! node (leftChild node))
							; (set! (leftChild node) nil)
							(set-car! node (car (leftChild node)))
							(set-cdr! node (list nil nil))
							(size-)
							)
						((null? (leftChild node))
							(if debug (println "Left child is null.  Replacing node with "  (rightChild node)))
							(set-car! node (car (rightChild node)))
							(set-cdr! node (list nil nil))
							(size-)
							)
						(else
							; Call the node to be deleted N.
							; Do not delete N.
							; Instead, choose either its in-order successor node or its in-order predecessor node, R.
							; Replace the value of N with the value of R, then delete R.
							(if debug (println "Complicated one. This probably fails..."))
							; (inspect (car (predecessor node)))
							; (inspect (car node))
							(define tmp (car (predecessor node)))
							(delete (car (predecessor node)))
							(set-car! node tmp)
							)
						)
					)
				)
			)
		(delete-helper base)
		)
	(define (traverse)
		(define (preorder node)
			(cond
				((null? node) nil)
				(else
					(print (car node) " ")
					(preorder (leftChild node))
					(preorder (rightChild node))
					)
				)
			)
		(preorder base)
		(newline)
		)
	(define (printTree)
		(println base)
		)
	this
	)


(define t (bst))
; ((t 'insert) 1 2 3 4 5 6 7 8 9 10)
((t 'insert) 3 4 5 1 0 2)
(newline)
(println "Test results: ")
(inspect ((t 'find) 5))   ; should return #t
(inspect ((t 'find) 7))   ; should return #f
(inspect ((t 'root)))     ; should return 3
(inspect ((t 'size)))     ; should return 6
(print "Pre-order traversal: ")
((t 'traverse)) ; should print 3 1 0 4 5
(print "Tree, literal representation: ")
((t 'printTree))

(newline)

; (println "Testing predecessor and successor...")
; (inspect ((t 'predecessor) (t' base)))
; (inspect ((t 'successor) (t' base)))

; (newline)

(println "Testing delete...")
(print "Pre-delete tree: ")
((t 'printTree))
(println "Trying: ((t 'delete) 3)")
((t 'delete) 3)
(newline)
(println "After delete:")
(print "Pre-order traversal: ")
((t 'traverse)) ; should print 3 1 0 4 5
(print "Tree, literal representation: ")
((t 'printTree))
(inspect ((t 'size)))     ; should return 5
(inspect ((t 'root)))     ; should return 2

; (define l '(1 (2 nil) 4))
; (inspect (cadr (cadr l)))
; (set-car! (cdr (cadr l)) 5)
; (inspect (cadr (cadr l)))
; (inspect l)
; (set-car! (cdr (cadr l)) (cons 9 (cons 99 999)))
; (inspect l)

; (define l2 '(5 (nil nil)))
; (define l3 '(5 ((nil (nil nil)) nil nil nil nil nil (nil (nil nil)))))
; (inspect l3)