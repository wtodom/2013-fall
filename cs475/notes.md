CS 475 - Programming Languages
==============================

## Regular Expressions - 28 August 2013

- TERM: Regular Expression = 
- TERM: Operators (in order of increasing precedence)
	- Union = or
	- Concatenation = (normal def.)
	- Asterisk (*) = repeat zero or more times

- EXAMPLE
	- strings over {a, b} with the 4rd rightmost symbol being "b"
	- (a UNION b)* b (a UNION b) (a UNION b)

##### Convert regex to NFSM

- notebook-7

- The NFSMs we construct will have one final state, and that state will be distinct from the start state.

- notebook-8

- notebook-9

- notebook-10

- IMAGE @ 1:45

- IMAGE @ 1:50

## Regular Expressions (cont.) - 4 September 2013

- Example:
	- Identifiers (start with a letter, and the rest of the characters are either letters, digits, or underscores)
	- letter(letter|digit|"_")*
	- the first instance of letter above is same as [a-z]|[A-Z] or [a-zA-Z]
	- same goes for digit: [0-9]
	- full regex: \[a-zA-Z]([a-zA-Z]|[0-9]|"_")*

- Example:
	- write an expression that captures any string over {a, b} where the # of a's is odd (inclusive) or the # of b's is odd.
	- jsut the a part: a(aa)\*
	- both: b*ab*(\*ab\*)\*|a\*ba\*(ba\*ba\*)\*

- Example:
	- converting from regex to non-deterministic finite state machine
	- notebook-17

##### more regex shorthands

- ? means optional. Ex: [0-9]? means a digit is optional
- Epsilon represents the empty string

##### Regex Properties

- Associative:
	- (RS)T = R(ST) = RST
	- (R|S)|T = R|(S|T) = R|S|T

- Commutative:
	- R|S = S|R
	- RS != SR

- Distributive:
	- R(S|T) = RS|RT
		- Remember, concatenation has higher precedence than union.
	- (R|S)T = RT|ST

## Regular Expressions (cont.) - 6 September 2013

- notebook-22

##### Converting FSM to RegExpr

- notebook-23
- Algorithm:
	- If either we have 2 or more final states OR the start state is a final state, create a new version of the FSM with the final states removed, then add an additional state that is final, along with epsilon edges/transitions leading to it from all of the original final states.
- general example: notebook-24
	- Once you're down to 2 states you can easily create regex.

- pseudocode for elimination process: notebook-25

- TERM: "Regular Language" = A language that is accepted by an FSM or generated by regex.

- example of a non-regular language
	- L = {AnBn}   (where n is an exponent in place of the *).
	- machine for above, notebook-26
	- How can we actually show/prove that L is not regular? 
		- There is a property that all regular languages have. Here are some properties of Regular Languages:
			- Suppose R is a RegLang.
			- Let M be a DFSM that accepts R.
			- Let P equal the number of states in M.
			- Suppose R contains a string S with length >= P.
			- notebook-27 for picture.
			- Accepting string S yields a path in machine M that includes >= P+1 states, and thus repeats at least one state.
			- Call the sequence of characters along the path from the start state until the first state that gets repeated "path U".
			- Call the set of nodes between visits to the repeated state path V.
			- Finally, call the path between the repeated state and the final state path W.
			- This leads to a theorem:
				- ##### Pumping Theorem for Regular Languages
					- Let L be any regular language.
					- There exists a constant P such that:
						- for every string s element L with len(s) >= p we can write s = uvw such that |uv| <= p and |v| >= 1 and every string u(v^k)w (u concatenated with k repeats of v concatenated to w) is in L for all k >= 0.
		- SO, back to the question (show that L is not regular). We'll use proof by contradiction.
			- Assume L is regular.
			- Choose a constant P.
			- let s = (a^p)(b^p). That is, p a's concatenated with p b's.
			- So, s = uvw where u = a^i (that is, some number of a's) and v = a^j (again, some number of a's). These must be true by the property of the pumping theorem.
			- Thus, w must = (a^(p-i-j))(b^p) (that is, the rest of the a's, then all of the b's).
			- By the second condition of the theorem, j >= 1.
			- Now, the contradiction. Choose any k to use in the third condition.
				- notebook-28

- Another example like above: notebook-32, notebook-33, notebook-34

## More Properties of Regular Languages

- Let R1 and R2 be any regular languages. Then these languages are also regular:
	1. R1 Union R2
		- Can use DeMorgan's Law on this (using style from compliment in below section):
			- not(not(R1) U not (R2))
	2. R1R2 (concatenation of them)
	3. R1\* (or R2\*)
- The above three rules follow from regex operators (union, concat, *)

- These languages are also regular:
	1. R1 Intersection R2 (notebook-40)
		- The number of states in the new machine will be num(R1) * num(R2), and the same goes for the number of final states.
	2. Compliment of R1 (or R2)
		- Simply swap final and non-final states
		- Note that you have to be careful of machines that let rejected strings go to a dead state (you have to actually add the dead state and make it final).
	3. Substitution or Homomorphism
		- notebook-42 for example
	4. Inverse Substitution or Inverse Homomorphism
		- notebook-43 for example
		- Image @ 1:53

- notebook-41 (example using above)

- Closure Properties
	- Regular languages are closed ("preserved") over:
		- Union
		- Concatenation
		- *
		- Intersection
		- Complement
		- Reverse

## 18 September 2013 - Regular or Not?

- Regular or not?
	- L1 = {a^n b^n}
		- Not regular by the pumping theorem (previous class)
	- L2 = {strings over {a,b} with #a's = #b's}
		- L1 = L2 Intersection a\*b\*
		- Assume L2 is regular.
		- a\*b\* is regular (since that's the regex for it)
		- The intersection of two languages must be regular, but since we know that L1 is irregular, we have a contradiction. Thus, L2 is irregular (since it was our only assumption).
	- L3 = {strings over {a^n b^n} with #a's != #b's}
		- L3 = Compliment(L2)
		- Assume L3 is regular.
		- Thus, the compliment must be regular (by the closure property).
		- However, L2 is irregular, so our assumption is wrong and :3 is irregular.
	- L4 = {a^m b^n | m != n}
		- Suppose L4 is regular.
		- L1 = Compliment(L4 Union a\*b\+a(a Union b)\*)
			- a\*b\+a(a Union b)\* = Compliment(a\*b\*)
		- The right side is regular, and so if L4 is regular then L1 must be also.
		- L1 is not regular, so our assumption is wrong, and L4 is not regular.


##### Reducing a FSM to a minimum number of states

- L = {strings over {a, b} such that either the string begins with a and has odd length, or begins with b and has even length}
	- notebook-48

- Uses a table of distinguishabilities (tells which states are equivalent or non-equivalent)
	- notebook-49 (filled in using below algorithm)

##### Minimization algorithm
	- for each final state q:
		- for each non-final state p:
			- mark square (p, q) with an "X"
	- while changes in the table are occuring:
		- for each pair of states p and q that are not yet marked with and "X":
			- for each character c in the alphabet:
				- if the square corresponding to the pair (delta(p, c), delta(q, c)) (that is the transition function evaluated at a certain state with some particular input) is marked, mark (p, q)
- Gives a DFSM with the fewest possible states.

##### Algorithms related to regular languages

- Given regular language L, does L = the empty set?
	- Suppose L has a FSM M.
	- Do a breadth or depth first search from the start state.
	- If we don't readh any final state then L = the empty set.

## 20 September 2013 - Regular Languages (cont.) and Context-free Grammars

- Given a regular language L, is L = Empty Set?
	- Algorithm:
		- Construct the FSM.
		- Search for a path from the start state to any final state.
		- If a path exists, L != Empty Set.

- Given string S, is S in L?
	- Algorithm:
		- Build DFSM.
		- Trace DFSM to follow path from start state.
		- If you end in a final state, S is in L.

- Is L = Sigma* (That is, every string over Sigma - all possible strings).
	- Algorithm:
		- Use closure property (complement(L) is regular if L is regular.)
		- Since L = Empty Set is regular, this one is regular too.

- Given regular languages L1 and L2, Does L1 = L2?
	- Algorithm:
		- Check if L1 Intersection Complement(L2) = Empty Set
		- Check if L2 Intersection Complement(L1) = Empty Set.
		- If either is non-empty, the languages are not equivalent.

##### Context-free Grammars (henceforth, "grammars"/"grammar")

- Still have concatenation and union, but they are restricted.
- Also have recursion.

- Example:
	- L = {a^n b^n}
		- accepts: Empty String, ab, aabb, aaabbb, ...
	- Replacement Rules: ("->" means "can be replaced by")
		- (1) S -> Empty String
		- (2) S -> aSb
		- the above two rules can be replaced by:
			- (1) S -> Empty String | aSb
	- Parse Tree
		- notebook-51
	- Derivation
		- Derivations go from the bottom of the parse tree towards the top.
		- built aaabbb by following rules: 2, 2, 2, 1

- Example:
	- L = {palindromes over {a, b}}
	- rules:
		- S -> Empty String
		- S -> aSa
		- S -> bSb
		- S -> a
		- S -> b

- Example:
	- L = {strings over {a. b} with #a's = #b's}
	- rules:
		- S -> Empty String
		- S -> aSb
		- S -> bSa
		- S -> SS