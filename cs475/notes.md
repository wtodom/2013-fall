CS 475 - Programming Languages
==============================

## Regular Expressions - 28 August 2013

- TERM: Regular Expression = 
- TERM: Operators (in order of increasing precedence)
	- Union = or
	- Concatenation = (normal def.)
	- Asterisk (*) = repeat zero or more times

- EXAMPLE
	- strings over {a, b} with the 4rd rightmost symbol being "b"
	- (a UNION b)* b (a UNION b) (a UNION b)

##### Convert regex to NFSM

- notebook-7

- The NFSMs we construct will have one final state, and that state will be distinct from the start state.

- notebook-8

- notebook-9

- notebook-10

- IMAGE @ 1:45

- IMAGE @ 1:50

## Regular Expressions (cont.) - 4 September 2013

- Example:
	- Identifiers (start with a letter, and the rest of the characters are either letters, digits, or underscores)
	- letter(letter|digit|"_")*
	- the first instance of letter above is same as [a-z]|[A-Z] or [a-zA-Z]
	- same goes for digit: [0-9]
	- full regex: \[a-zA-Z]([a-zA-Z]|[0-9]|"_")*

- Example:
	- write an expression that captures any string over {a, b} where the # of a's is odd (inclusive) or the # of b's is odd.
	- jsut the a part: a(aa)\*
	- both: b*ab*(\*ab\*)\*|a\*ba\*(ba\*ba\*)\*

- Example:
	- converting from regex to non-deterministic finite state machine
	- notebook-17

##### more regex shorthands

- ? means optional. Ex: [0-9]? means a digit is optional
- Epsilon represents the empty string

##### Regex Properties

- Associative:
	- (RS)T = R(ST) = RST
	- (R|S)|T = R|(S|T) = R|S|T

- Commutative:
	- R|S = S|R
	- RS != SR

- Distributive:
	- R(S|T) = RS|RT
		- Remember, concatenation has higher precedence than union.
	- (R|S)T = RT|ST

## Regular Expressions (cont.) - 6 September 2013

- notebook-22

##### Converting FSM to RegExpr

- notebook-23
- Algorithm:
	- If either we have 2 or more final states OR the start state is a final state, create a new version of the FSM with the final states removed, then add an additional state that is final, along with epsilon edges/transitions leading to it from all of the original final states.
- general example: notebook-24
	- Once you're down to 2 states you can easily create regex.

- pseudocode for elimination process: notebook-25

- TERM: "Regular Language" = A language that is accepted by an FSM or generated by regex.

- example of a non-regular language
	- L = {AnBn}   (where n is an exponent in place of the *).
	- machine for above, notebook-26
	- How can we actually show/prove that L is not regular? 
		- There is a property that all regular languages have. Here are some properties of Regular Languages:
			- Suppose R is a RegLang.
			- Let M be a DFSM that accepts R.
			- Let P equal the number of states in M.
			- Suppose R contains a string S with length >= P.
			- notebook-27 for picture.
			- Accepting string S yields a path in machine M that includes >= P+1 states, and thus repeats at least one state.
			- Call the sequence of characters along the path from the start state until the first state that gets repeated "path U".
			- Call the set of nodes between visits to the repeated state path V.
			- Finally, call the path between the repeated state and the final state path W.
			- This leads to a theorem:
				- ##### Pumping Theorem for Regular Languages
					- Let L be any regular language.
					- There exists a constant P such that:
						- for every string s element L with len(s) >= p we can write s = uvw such that |uv| <= p and |v| >= 1 and every string u(v^k)w (u concatenated with k repeats of v concatenated to w) is in L for all k >= 0.
		- SO, back to the question (show that L is not regular). We'll use proof by contradiction.
			- Assume L is regular.
			- Choose a constant P.
			- let s = (a^p)(b^p). That is, p a's concatenated with p b's.
			- So, s = uvw where u = a^i (that is, some number of a's) and v = a^j (again, some number of a's). These must be true by the property of the pumping theorem.
			- Thus, w must = (a^(p-i-j))(b^p) (that is, the rest of the a's, then all of the b's).
			- By the second condition of the theorem, j >= 1.
			- Now, the contradiction. Choose any k to use in the third condition.
				- notebook-28

- Another example like above: notebook-32, notebook-33, notebook-34

## More Properties of Regular Languages

- Let R1 and R2 be any regular languages. Then these languages are also regular:
	1. R1 Union R2
		- Can use DeMorgan's Law on this (using style from compliment in below section):
			- not(not(R1) U not (R2))
	2. R1R2 (concatenation of them)
	3. R1\* (or R2\*)
- The above three rules follow from regex operators (union, concat, *)

- These languages are also regular:
	1. R1 Intersection R2 (notebook-40)
		- The number of states in the new machine will be num(R1) * num(R2), and the same goes for the number of final states.
	2. Compliment of R1 (or R2)
		- Simply swap final and non-final states
		- Note that you have to be careful of machines that let rejected strings go to a dead state (you have to actually add the dead state and make it final).
	3. Substitution or Homomorphism
		- notebook-42 for example
	4. Inverse Substitution or Inverse Homomorphism
		- notebook-43 for example
		- Image @ 1:53

- notebook-41 (example using above)

- Closure Properties
	- Regular languages are closed ("preserved") over:
		- Union
		- Concatenation
		- *
		- Intersection
		- Complement
		- Reverse

## 18 September 2013 - Regular or Not?

- Regular or not?
	- L1 = {a^n b^n}
		- Not regular by the pumping theorem (previous class)
	- L2 = {strings over {a,b} with #a's = #b's}
		- L1 = L2 Intersection a\*b\*
		- Assume L2 is regular.
		- a\*b\* is regular (since that's the regex for it)
		- The intersection of two languages must be regular, but since we know that L1 is irregular, we have a contradiction. Thus, L2 is irregular (since it was our only assumption).
	- L3 = {strings over {a^n b^n} with #a's != #b's}
		- L3 = Compliment(L2)
		- Assume L3 is regular.
		- Thus, the compliment must be regular (by the closure property).
		- However, L2 is irregular, so our assumption is wrong and :3 is irregular.
	- L4 = {a^m b^n | m != n}
		- Suppose L4 is regular.
		- L1 = Compliment(L4 Union a\*b\+a(a Union b)\*)
			- a\*b\+a(a Union b)\* = Compliment(a\*b\*)
		- The right side is regular, and so if L4 is regular then L1 must be also.
		- L1 is not regular, so our assumption is wrong, and L4 is not regular.


##### Reducing a FSM to a minimum number of states

- L = {strings over {a, b} such that either the string begins with a and has odd length, or begins with b and has even length}
	- notebook-48

- Uses a table of distinguishabilities (tells which states are equivalent or non-equivalent)
	- notebook-49 (filled in using below algorithm)

##### Minimization algorithm
	- for each final state q:
		- for each non-final state p:
			- mark square (p, q) with an "X"
	- while changes in the table are occuring:
		- for each pair of states p and q that are not yet marked with and "X":
			- for each character c in the alphabet:
				- if the square corresponding to the pair (delta(p, c), delta(q, c)) (that is the transition function evaluated at a certain state with some particular input) is marked, mark (p, q)
- Gives a DFSM with the fewest possible states.

##### Algorithms related to regular languages

- Given regular language L, does L = the empty set?
	- Suppose L has a FSM M.
	- Do a breadth or depth first search from the start state.
	- If we don't readh any final state then L = the empty set.

## 20 September 2013 - Regular Languages (cont.) and Context-free Grammars

- Given a regular language L, is L = Empty Set?
	- Algorithm:
		- Construct the FSM.
		- Search for a path from the start state to any final state.
		- If a path exists, L != Empty Set.

- Given string S, is S in L?
	- Algorithm:
		- Build DFSM.
		- Trace DFSM to follow path from start state.
		- If you end in a final state, S is in L.

- Is L = Sigma* (That is, every string over Sigma - all possible strings).
	- Algorithm:
		- Use closure property (complement(L) is regular if L is regular.)
		- Since L = Empty Set is regular, this one is regular too.

- Given regular languages L1 and L2, Does L1 = L2?
	- Algorithm:
		- Check if L1 Intersection Complement(L2) = Empty Set
		- Check if L2 Intersection Complement(L1) = Empty Set.
		- If either is non-empty, the languages are not equivalent.

##### Context-free Grammars (henceforth, "grammars"/"grammar")

- Still have concatenation and union, but they are restricted.
- Also have recursion.

- Example:
	- L = {a^n b^n}
		- accepts: Empty String, ab, aabb, aaabbb, ...
	- Replacement Rules: ("->" means "can be replaced by")
		- (1) S -> Empty String
		- (2) S -> aSb
		- the above two rules can be replaced by:
			- (1) S -> Empty String | aSb
	- Parse Tree
		- notebook-51
	- Derivation
		- Derivations go from the bottom of the parse tree towards the top.
		- built aaabbb by following rules: 2, 2, 2, 1

- Example:
	- L = {palindromes over {a, b}}
	- rules:
		- S -> Empty String
		- S -> aSa
		- S -> bSb
		- S -> a
		- S -> b

- Example:
	- L = {strings over {a. b} with #a's = #b's}
	- rules:
		- S -> Empty String
		- S -> aSb
		- S -> bSa
		- S -> SS

- If a CFG has more than one possible parse tree for any string in the language it is considered "ambiguous", and is not ideal.

## 23 September 2013

- Example: Table of Distinguishabilities - image @ 1:16
	- correction: 4 is still a final state in the reduced version

- Every regular language has a context free grammar
	- Converstion Example: notebook-52 (using outgoing edges) (aka right linear)
	- Another conversion: notebook-53 (using incoming edges) (aka left linear)
- Linear Grammar
	- Every right side of production (right of the ->) has at most one rule.

## 27 September 2013 - Simplifying/improving ambiguous CFGs

- Example:
	- notebook-56 (wrote all on paper to test new pencil)

##### Arithmetic Expressions

- Ex: (a + b) * (c - d)
	- this is infix notation
	- Let "E" generate an expression:
		- grammar: notebook-57

- Ex: * + a b - c d (prefix)
	- notebook-58

- Ex: a b + c d - * (postfix)
	- notebook-59

## 30 September 2013 - Arithmetic Expressions (cont.)

- Adding precedence: can use something like this format:
	- Expr = Term + Term - Term + Term
	- Term = Factor * Factor / Factor
	- This translates into:
		- E -> E+E | E-E | T (see change below)
		- [empty line because I broke formatting somehow...]
		- T -> T*T | T/T | F
		- F -> (E) | Var
	- Parse tree for a-b*c: notebook-60
		- This is still ambiguous in cases where you have multiple operators at the same precednece level (for example, a-b+c)
	To fix it, change the def of E above to:
		- E -> E+T | E-T | T
		- This makes it left-associative. The fact that the rule is left-recursive is what makes it left-associative.
		- This change makes it unambiguous.

- If statements:
	- most languages have two forms:
	- S -> if (E) S | if (E) S else S | (other things)
	- E -> (some definition for expressions)
	- This is ambiguous. For example:
		if (something)
			if (something)
				other
			else
				other
	- The else could stick to either if.
	- To fix it, add additional symbols:
		- U for "unmatched"
		- M for "matched"
		- new version:
			- S -> M | U
			- M -> if (E) M else M | (other things)
			- U -> if (E) S | if (E) M else U

## 2 October 2013 - Pushdown Automata (PDA)

- PDA = FSM + Stack
- Notation: notebook-61
- Example: L = {a^n b^n}:
	- notebook-62
	- Z0 = bottom-of-stack symbol
- Example: L = {strings over {a, b} where #a's == #b's}
	- notebook-63
- Example: L = {palindromes over {a, b}}
	- notebook-63

## 4 October 2013 (PDA and CFG review, quiz monday on CFGs)

- examples in notebook (68-72)
- Relationship between CFG and PDA:
	- If a string comes before the variable in the CFG, push something on the stack in the PDA. Likewise, if a string comes after the variable, pop something off the stack.

## 9 October 2013

- Example from last time - notebook-80

- Computation Sequence for PDA
	- notation: (current state, remaining input, stack contents)
	- shorthand for notation: only do (state, stack) but include input on edges between them.

- *** notebook-81 ***
	- Differences between FSM and PDA
	- notebook-82: differences between different transition functions.

- We showed previously that Regular Expressions, DFSMs, and NFSMs were equivalent. We will soon show that CFGs and NPDAs are analogously equivalent, but DPDAs are less powerful.

## 11 October 2013 (PDA cont.)

##### For DPDA
- Prefix property:
	- if w ELEMENT L then no prefix of w is in L.
		- If w = abcde ELEMENT L:
			[a, ab, abc, abcd, EPSILON] are not in L.
- If a language satisfies the prefix property, the ending in a final state and popping the bottom of stack are equivalent ways to accept a string.

- Adding an "end of inupt" symbol is a way to allow a DPDA for a language like {A^n B^n}

### Algorithm for converting CFG -> NPDA

1. For each rule of the form "a -> b", add a transition like "E, a/b" (where "E" = epsilon)
2. For each item 'c' in the language, make a rule like "c, c/E"

## 14 October 2013 - Converting PDA -> CFG

* Not on quiz *

- Identifying useless variables in a grammar
	1. Identify for each variable T, is there some sequence starting with T that lets us derive some string alpha?
		- Every rule (or partial rule) that cannot produce symbols terminally is eliminated
	2. Identify for each variable T, is there a sequence of productions that, starting with S, can reach alpha T beta?

## 16 October 2013

- Removing Epsilon production
	1. identify "nullable" symbols
		- A symbol is nullable if it can produce a string containing nothing but epsilon by any series of operations.
	2. Take away the Epsilong rules (the rules/options that are Epsilon)
	3. add back rules that produce the lost strings.
		- notebook-89
	4. Special case - if S in nullable then the language contained Epsilon, but it won't after applying this process (the language is changed).

- Removing unit productions
	- unit productions are rules where one variable simply produces another single variable.
	- Algo:
		1. Find all pairs (X, Y) such that X produces Y (unit production)
			- include transitive pairs, such as A -> B -> C => A -> C
		2. Remove unit productions from the grammar
		3. Add new rules in place of unit productions, essentially skipping the removed step.
			- notebook-90
			- For each pair (X, Y) and each rule Y -> alpha, add new rule: X -> alpha
		4. If a rule that produces some string is only encountered as a unit production, you can eliminate that rule after eliminating the unit productions.
			- Also in notebook-90

- Convert to Chomsky Normal Form (CNF)
	- Every production is in one of two formats:
		1. X -> YZ (two variables)
		2. X -> a (a single non-variable)
	- Algo:
		1. Remove epsilon productions
		2. Remove unit productions
		3. Factor out (replace with new variables) any alphabet characters (terminals) that occur in a longer right-hand side (ones that are more than single symbols)
		4. Factor out groups of two variables that are part of a longer right-hand side
		